# geo-service
Разработан в соответствии с [Заданием](https://github.com/bugakov-sa/geo-service/blob/master/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%BE%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20-%20%D0%B3%D0%B5%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81.pdf)

### Стек технологий, сборка и запуск
Проект разработан на стеке [Scala](https://www.scala-lang.org/) - [Akka-HTTP](http://doc.akka.io/docs/akka-http/current/scala.html) - [SBT](http://www.scala-sbt.org/)

Для сборки приложения из исходников необходимо в директории geo-service выполнить команду
```
sbt pack
```
Для сборки используется [sbt-pack plugin](https://github.com/xerial/sbt-pack)

После успешного выполнения этой команды, собранное приложение будет в папке geo-service/target/pack Эту папку можно скопировать в любое другое место. И запускать приложение с помощью скрипта из pack/bin

Структура директории pack:

1. Папка lib - в этой папке находятся jar-файл приложения и jar-файлы зависимостей.
2. Папка bin - в этой папке находятся скрипты запуска и файл с настройками приложения.
3. Папка data - в этой папке находятся таблицы с данными о метках пользователей и географической сетке.
4. Папка script - в этой папке находятс скрипты генерации файлов в папке data

В сборке уже есть сгенерированные данные в папке data. Вы можете заново сгенерировать метки пользователей и получить новый набор меток. Генерировать заново географическую сетку нет смысла - алгоритм неслучайный. Подробнее о содержимом папок script и data будет рассказано ниже.

###HTTP API
Реализовано в виде get-запросов. Рассмотрим пример каждого запроса.
#### Добавление или изменение метки пользователя
/users/update?id=1&lat=-45.8779978817&lon=33.5622549935
#### Удаление метки пользователя
/users/delete?id=1
#### Запрос метки пользователя
/users/select?id=1

Этого запроса нет в задании, он реализован для удобства тестирования.
#### Проверка, находится ли метка пользователя рядом с указанной в запросе точкой
/users/location?id=1&lat=-45.8779978817&lon=33.5622549935
#### Запрос числа пользователей в ячейке сетки, в которой находится указанная в запросе точка
/zones/count?lat=-45.8779978817&lon=33.5622549935

### Сложность выполнения запросов
Константная, О(1). 

В случае запросов /users/update, /users/delete выполняется обращение к хеш-таблице пользователей ([ConcurrentHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html)) и к хеш-таблице cчетчиков пользователей ([Immutable HashMap](http://www.scala-lang.org/api/current/scala/collection/immutable/HashMap.html)). 

В случае запроса /users/select выполняется обращение к хеш-таблице пользователей.

В случае запроса /users/location - обращение к хеш-таблице пользователей и обращение к хеш-таблице геозон ([Immutable HashMap](http://www.scala-lang.org/api/current/scala/collection/immutable/HashMap.html)). 

В случае запроса /zones/count - обращение к хеш-таблице cчетчиков пользователей.

Расчет числа пользователей count(z) в геозоне z реализован из следующего соображения:

count(z) в момент времени t = число входов пользователей в z в интервале времени [t0, t] - число выходов пользователей из z в интервале времени [t0, t], t0 - момент старта приложения

Каждый запрос update интерпретируется, либо как вход в зону (если это новый пользователь), либо как выход из одной зоны и вход в другую зону.

Каждый запрос delete интерпретируется, как выход из зоны (если указанный в запросе ИД пользователя существует).

Поскольку набор зон известен на момент старта приложения, можно на старте создать [Immutable HashMap](http://www.scala-lang.org/api/current/scala/collection/immutable/HashMap.html) с ключом (широта, долгота) и значением [AtomicLong](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLong.html) = 0 и при каждой операции update/delete изменять соответствующие счетчики.

### Замечания по архитектуре, варианты дальнейшего развития.
В [Задании](https://github.com/bugakov-sa/geo-service/blob/master/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%BE%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20-%20%D0%B3%D0%B5%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81.pdf) указано максимальное число меток пользователей - 10 миллионов. Запись каждой метки состоит из трех полей: ИД пользователя - 8 байт, широта - 8 байт, долгота - 8 байт. Итого, 24 байта полезной информации. Попробуем прикинуть объем служебных данных. [Беглый гуглинг](https://habrahabr.ru/post/124909/) говорит, что, например, LinkedList[Double] может держать в памяти до 40 байт служебных данных на элемент списка, а LinkedList[String] - до 80 байт на элемент. Про мапы, увы, ничего не сказано. Будем надеяться, что будет не больше 120 байт служебных данных на одну пару (ключ-значение). Тогда, в худшем случае (при 10 миллионах пользователей), мапа этих пользователей в памяти займет не больше полутора гигов. Отсюда, вывод - при выполнении тестового задания для упрощения разработки и тестирования приложения можно хранить метки пользователей в памяти.

В данном проекте не реализовано сохранение меток пользователей при завершении работы приложения.

Приложение может быть доработано для реализации отказоустойчивого геосервиса. При этом не нужно будет менять бизнес-логику, в частности: [апи и код контроллера](https://github.com/bugakov-sa/geo-service/blob/master/src/main/scala-2.11/testtask/rest/Controller.scala), [код расчета статистики](https://github.com/bugakov-sa/geo-service/blob/master/src/main/scala-2.11/testtask/service/ZonesStatService.scala) и [код проверки местоположения пользователя](https://github.com/bugakov-sa/geo-service/blob/master/src/main/scala-2.11/testtask/service/TestLocationService.scala). Порядок действий при реализации отказоустойчивости следующий:

1. Задачу хранения меток пользователей и географической сетки переложить на СУБД. 10 миллионов записей - небольшой объем, можно использовать, как NoSQL, так и RDBMS, например, [Postres](https://www.postgresql.org/). Реализовать [UsersDao](https://github.com/bugakov-sa/geo-service/blob/master/src/main/scala-2.11/testtask/dao/UsersDao.scala) и [ZonesRef](https://github.com/bugakov-sa/geo-service/blob/master/src/main/scala-2.11/testtask/ref/ZonesRef.scala) для внешней БД.
2. [Компонент расчета статистики](https://github.com/bugakov-sa/geo-service/blob/master/src/main/scala-2.11/testtask/service/ZonesStatService.scala) выделить в отдельныое приложение. Назовем его StatService.
3. В geo-service поддержать рассылку уведомлений об операциях update/delete нескольким инстансам StatService.
4. Запустить два экземпляра геосервиса.
5. Запустить два экземпляра статсервиса.

Рассмотрим вырианты отказов:

1. Выключение геосервиса. Клиент, зная адреса всех нод геосервиса, в случае недоступности одной ноды отправляет запрос на другую ноду. После подъема упавшего геосервиса, он сразу же становится активным.
2. Выключение статсервиса. Геосервис, обрабатывая запрос zones/count, в случае падения одной ноды статсервиса, отправляет запрос на другую ноду статсервиса. После того, как выключенный статсервис поднялся, он считается неактивным (игнорирует) запросы в течение некоторого таймаута. Таймаут выставляется, исходя из частоты обращения пользователей с запросами update/delete. Необходимо выставить такой таймаут, за который геосервис соберет актуальную статистику о местоположениях пользователей. Однако, если пользователи оповещают о своем местоположении слишком редко, то придется переделывать реализацию статсервиса.

Следует также заметить, что вычисление статистики за константное время возможно далеко не для всех статистик. Например, для вычисления дисперсии меток в геозоне необходимо работать со списком всех меток, которые находятся в этой геозоне. В таких случаях статсервис должен либо работать с хранилищем данных, либо накапливать в себе необходимую для вычисления статистики информацию в более сложной структуре, нежели AtomicLong.

### Алгоритмы генерации данных
Реализованы на [python 2](https://docs.python.org/2/). [/script](https://github.com/bugakov-sa/geo-service/blob/master/script)

#### Генерация меток пользователей
Метка - пара чисел, широта и долгота. Самый простой способ генерации тестового набора меток - из равномерных распределений (от -180 градусов до +180 градусов для долготы и от -90 градусов до +90 градусов для широты). Недостаток такого способа - разная плотность меток в разных широтах, самая низкая - на экваторе, а самая высокая - на полюсах. То есть, при самом примитивном подходе, мы посредством равномерных распределений размечаем земной шар метками неравномерно. Неинтересно.

Будем генерировать метки так, чтобы они были равномерно распределены по земной поверхности. Долготу будем генерировать из равномерного распределения. Генерация широты посложнее.

Обозначим R - радиус земного шара, lat - широта в радианах (варьируется от -Pi/2 до +Pi/2). Разберем алгоритм генерации широты для точек северного полушария. В южном полушарии изменится лишь знак lat.

Длина параллели широты lat: L(lat) = 2 * Pi * R * sin(lat). 
     
Эта фукнция убывает от 2 * Pi * R на экваторе до 0 на северном полюсе. Эта фукнция определяет закон убывания вероятности появления метки на широте lat. 

Чтобы получить функцию плотности вероятности f(lat), L(lat) нужно нормировать, поделив на интеграл L(lat) на отрезке [0, Pi/2]. Обозначим этот интеграл I. 

Фукнция плотности вероятности генерации метки на широте lat: f(lat) = 2 * Pi * R * sin(lat) / I. 

Для генерации распределения с плотностью f, необходима обратная фукнция lat(f) = arcsin(I * f / (2 * Pi * R)). 

Диапазон изменения f - от 0 до f(0) = 2 * Pi * R / I. Обозначим r - равномерно распределенная случайная величина из отрезка от 0 до 1. 

Тогда алгоритм генерации широты метки в серверном полушарии: lat = arcsin(I * (r * 2 * Pi / I) / (2 * Pi * R)) = arcsin(r).

Реализация алгоритма: [users.py](https://github.com/bugakov-sa/geo-service/blob/master/script/users.py). Результат работы алгоритма: [users.csv](https://github.com/bugakov-sa/geo-service/blob/master/data/users.csv).

#### Генерация географической сетки
###### Примитивный алгоритм. 
В качестве опорных точек взяты точки с целочисленными координатами. Реализация алгоритма: [zones.py](https://github.com/bugakov-sa/geo-service/blob/master/script/zones.py). Результат работы алгоритма: [zones.csv](https://github.com/bugakov-sa/geo-service/blob/master/data/zones.csv)

###### Продвинутый алгоритм (пункт 3 [Задания](https://github.com/bugakov-sa/geo-service/blob/master/%D0%A2%D0%B5%D1%81%D1%82%D0%BE%D0%B2%D0%BE%D0%B5%20%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20-%20%D0%B3%D0%B5%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81.pdf)).
